객체지향(객체중심) 프로그래밍(OOP:Object Oriented Programming)
- 객체를 기반으로 하는 프로그램
객체를 구성하고 객체단위로 프로그래밍한다
현실의 모든 사물은 객체라 볼 수 있다
클래스  의 구성요소 : 필드, 메소드, 생성자

자동차 는 객체
차종, 년식, 주행거리 특성 있고
전진하기, 멈추기, 후진하기 등의 기능이 있다

은행계좌 도 객체
예금주, 계좌번호, 잔액 특성 있고
입금하기, 출금하기 등의 기능이 있다

객체는 특성(상태)과 객체가 하는 행동 (기능)이 있다
프로그램에서는 특성을 데이터로, 기능을 메소드로 표현한다
 
데이터와 메소드간에는 긴밀한 관계가 있다

class 자동차 {
	차종, 속도 - 데이터: 변수
	주행한다.  - 메소드
	멈춘다.    - 메소드
} 

class 은행계좌 {
	예금주, 계좌번호, 잔액 - 데이터: 변수
	입금한다 - 메소드
	출금한다 - 메소드
}

클래스: 객체를 만들어내기 위한 틀, 그 자체가 데이터타입 - reference 타입
그 틀로 만들어낸 결과물이 객체
클래스명은 시작은 대문자로.
메소드명, 변수명은 시작은 소문자로, 단어단위로 첫문자를 대문자로
변수(로컬변수, 필드)가 final(상수) 인 경우 모두 대문자로 명명한다. 

class  돼지저금통  PiggyBank{
	데이터:변수
	주인 owner
	총액 total
	돈을 넣는다  inputMoney
	돈을 빼낸다  outputMoney
}

클래스에 선언한 변수는 객체가 생성될 때 메모리할당을 받게되고(메모리에 올려지는데) 이 과정을 인스턴스화 라 한다
클래스에 선언한 변수: 인스턴스변수, 필드, 멤버변수
구성요소들 간에는 레벨이 동등하다. - 순서가 없다
일반적으로 필드 -> 생성자 -> 메소드 선언 의 순서로 클래스를 선언한다.

클래스를 틀로 해서 객체를 만들어낸다.
객체 생성문:  new 클래스명();
객체 생성 = 인스턴스 생성

인스턴스화된 객체 메모리 어딘가에 위치하고 있고 존재위치는 주소값.
주소값은 참조변수에 담아두고 주소값을 참조해서 사용한다.
클래스명(데이터타입)  참조변수 = new 클래스명();

클래스: 객체를 만들어내기 위한 틀, 데이터타입
필드는 초기화하지 않아도 데이터타입에 맞는 기본값을 갖는다
수치형: 0   - byte, short, int, long, float, double, char
boolean: false
String : 참조타입( reference 타입)
reference 타입은 주소를 참조한다 -> 기본값은 주소없음에 해당하는  null
String str; 

클래스 구성요소(멤버): 필드, 메소드, 생성자
객체사용의 흐름
1. 객체 생성하기
2. 필드에 데이터값 저장하기
3. 객체의 메소드 호출하기
-> 객체를 생성하자마자 필드에 데이터값을 대입해서 초기화 함.
     초기화 하면서 객체를 생성해 본다.
   : 생성자
   
생성자 선언
1. 클래스 안에 선언
2. 생성자명은 클래스명과 동일
3. 리턴타입이 없는 메소드의 형식


파라미터가 없는 생성자는 default 생성자이다.
1. 클래스에 default  생성자가 선언이 되어 있지 않으면 
     컴파일러가 자동으로 선언해준다.
2. 파라미터가 있는 생성자가 한 개라도 선언이 되어 있으면
     컴파일러는  default 생성자를 자동선언해 주지 않는다.
3. 파라미터가 있는 생성자가 선언되어 있는 경우, 
     파라미터 없는 생성자로 객체를 생성하려면 명시적으로  default 생성자를 선언해야 한다
      
     
     
     
     
          
회원정보 클래스
필드
회원가입시 필수항목, 선택항목 이 있다
필수항목: 이름, 아이디, 비밀번호
선택항목: 전화번호, 나이 

선택항목중 전화번호/나이 모두 입력, 전화번호만 입력, 나이만 입력, 입력 안하는 경우

기능(메소드)
비밀번호 를 변경한다. 전화번호를 변경한다. 나이를 변경한다

생성자 파라미터의 갯수를 다르게 하거나
생성자 파라미터의 데이터 타입을 서로 다르게 하여
생성자를 여러개 선언하는 것 : 생성자 오버로딩


메소드 선언: 코드의 중복을 제거하고 메소드를 선언해서 코드는 한 번만 작성하고
          메소드호출문으로 사용하여 메소드 재사용 하게 됨
객체지향프로그램은 코드의 중복을 제거하고 재사용하도록 하는 것을 목표로 한다           


Account, GoodsStock, Product 클래스에는
생성자 선언문에 코드의 중복이 있다. 
이 부분을 생성자 호출문으로 바꿔본다.

생성자 선언문, 메소드 선언문에 익셉션을 발생시키는 처리가 있다면
throw new Exception("익셉션에 대한 적절한 메시지");
생성자 선언문, 메소드 선언문 본체 {} 시작전에 익셉션을 던지는 처리가 있어야 한다
throws Exception
생성자 호출, 메소드 호출시 반드시     try ~ catch 문으로 처리해야만 한다.


메소드 선언시
메소드명을 다르게 선언했었다.

생성자 선언시 
생성자명이 동일한데 생성자가 파라미터의 갯수가 다르게,
파라미터의 데이터 타입을 다르게 해서 여러 개 선언하는 것: 생성자 오버로딩


메소드 선언시
메소드명은 동일하게 메소드 파라미터의 갯수가 다르게,
파라미터의 데이터타입을 다르게 해서 여러 개 선언하는 것: 메소드 오버로딩


클래스의 멤버(구성요소) : 필드, 생성자, 메소드
클래스를 틀로 객체를 생성하면 각 객체마다 클래스의 구성요소들이 인스턴화 되어 진다.

특정 객체에 속하지 않고 클래스 자체에 속하는 
클래스 를 틀로해서 생성된 객체라면 모든 객체에서 공유해서 사용할 수 있는 구성요소
: 정적구성요소 static  

특정 객체에 속하지 않고 기능만 처리를 하는 경우  static  메소드로 선언해 볼 수 있다.
static 필드는 static 초기화블럭으로 초기화 할 수 있다
static {}
  








